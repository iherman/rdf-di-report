# Introduction

The [Verifiable Credentials Working Group](https://www.w3.org/groups/wg/vc) is finalizing the [[[vc-data-integrity]]] [[vc-data-integrity]] specification, as well as related "cryptosuites" ([[vc-di-ecdsa]] and [[vc-di-eddsa]]), whose goal is to provide standard means to secure Verifiable Credentials [[vc-data-model-2.0]]. The details of Verifiable Credentials are not important here (the interested reader may want to look at the [[[vc-overview]]] [[vc-overview]] document); suffices it to say that Verifiable Credentials are defined through RDF datasets [[rdf11-concepts]] represented using [[json-ld11]]. These datasets are secured by generating separate _proof graphs_,
each containing a cryptographic signature. The signature data are expressed in a small [vocabulary](https://w3id.org/security) defined by the [[vc-data-integrity]] specification.

The [[[vc-data-integrity]]] is defined for Verifiable Credentials. It uses a JSON-LD terminology and relies on some specificities of those credentials (more about this later). However, from the very start, an unofficial goal was to make the general approach, the underlying vocabulary, and cryptographic definitions, usable for RDF Datasets in general as well. The question is, therefore: "Is it possible, using the [[[vc-data-integrity]]] specification, to secure, via cryptographic signatures, RDF Datasets in general?". As we will see later, the answer to the question is "Almost". The goal of this document is to give a more precise answer, and some additional comments, based on an experimental implementation [[rdfjs-di]] by the author of this report.

## Technical basics

It is necessary, to make this document understandable to give some high level overview on the technical approach taken by [[vc-data-integrity]].

The operations of Data Integrity are conceptually simple. To create a cryptographic proof, the following steps are performed: 1) Transformation, 2) Hashing, and 3) Proof Generation.

1. _Transformation_ is a takes input data and prepares it for the hashing process. For RDF Datasets this involves the canonicalization of the RDF Datasets using the [[[rdf-canon]]] [[rdf-canon]] specification.
2. _Hashing_ calculates an identifier for the transformed data using a [cryptographic hash function](https://en.wikipedia.org/wiki/Cryptographic_hash_function); this is also defined by the [[rdf-canon]] specification.
3. _Proof Generation_ means, for our purposes, to generate a cryptographic signature using asymmetric keys, yielding the signature of the RDF Dataset. The details, defining the necessary vocabulary, is defined in [[vc-data-integrity]] and its adaptation to specific cryptographic schemes in [[[vc-di-eddsa]]] [[vc-di-eddsa]] and [[[vc-di-ecdsa]]] [[vc-di-ecdsa]]. Using other cryptographic schemes (e.g., RSA variants) would also be possible by adapting, say, the [[vc-di-eddsa]] specification.

The result of these steps is a _proof graph_ that contains the public key for the signature, the signature value itself, and some metadata. 

_Verification_ of a proof involves repeating calculating the hash values on the verifier's side and cryptographically check the signature value against the hash.

# Generating proof graphs

Generating proof graphs, following the general principles and the standard specifications is possible without further ado. There is nothing that would be Verifiable Credential or JSON-LD specific so far.

A simple example is as follows. Take the following, very simple RDF graph:

```turtle
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix earl: <http://www.w3.org/ns/earl#> 
          
<https://www.ivan-herman.net/foaf#me> a foaf:Person, earl:Assertor;
  foaf:name     "Ivan Herman";
  foaf:title    "Implementor";
  foaf:homepage <https://www.ivan-herman.net/> .
```

The corresponding proof graph, as generated by [[rdfjs-di]], and using the EdDSA signature scheme [[RFC8032]], is as follows:

```turtle
@prefix sec: <https://w3id.org/security#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
      
<urn:uuid:08bd1ede-34ea-4260-b698-81c2c28ccc0b> a sec:DataIntegrityProof;
    sec:verificationMethod <urn:uuid:33076c22-defc-45ec-8233-73e491cb4e69>;
    sec:created "2024-09-03T11:24:59.957Z"^^xsd:dateTime;
    sec:proofPurpose sec:authenticationMethod, sec:assertionMethod;
    sec:cryptosuite "eddsa-rdfc-2022";
    sec:proofValue "uhK6m9wekXiInuhnxv4Hx9rcs5--DbUZYZISpDeNuMEo2j48iZSB2Lp_OSd7D0h7Km0vRRbqWjWFknxis7JXBBA".
        
<urn:uuid:33076c22-defc-45ec-8233-73e491cb4e69> a sec:Multikey;
    sec:controller <https://example.org/key/#ivan_eddsa>;
    sec:expires "2055-02-24T00:00:00Z"^^xsd:dateTime;
    sec:publicKeyMultibase "z6MkqPUPcdvvixcfgGqqEZJ4WZTiDwaCsqF8jHqR5UZA2iae".
```

The first resource identifies the signature itself (the cryptographic value being the object of the `sec:proofPurpose` property) with some corresponding metadata.
The second resource identifies an asymmetric key (encoded using a so-called <a data-cite="controller-document#multikey">Multikey</a> format). The `sec:verificationMethod` provides a "bridge" between these two resources.

# Relating RDF Datasets with their signatures

The previous section may suggest that there is no real issue with the usage of Data Integrity for RDF Datasets, so the answer to the question of the introduction should be "Yes".

However, there is question that should also be answered and which does create problems, and that is: "How do I _link_ my Datasets with its proof graph?". Also, another similar question is: "How do I decide which triples must be signed for a given signature?".

For the case of a Verifiable Credentials, it is relatively straightforward to answer these questions. Indeed, the graph of a Credential is usually "tree-like", with the credentials' identifier identifying the root node; it is therefore perfectly fine to consider it as a natural anchor, and the tree itself as the content to be signed. Consider the following, simple Credential (where the `id` property is an alias to the `@id` JSON-LD keyword):

```json
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/Credential123",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "issuer": "did:example:2g55q912ec3476eba2l9812ecbfe",
  "validFrom": "2010-01-01T10:32:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Pat",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
```

For the Verifiable Credentials case, the Data Integrity specification introduces a `proof` property. The subject of the corresponding triple is the Credential itself, and object of the triple is a named graph that contains a single proof graph. [](#info-graph-vc) (borrowed from the [[vc-data-model-2.0]]) shows the structure in terms of RDF graphs:

<figure id="info-graph-vc">
<img style="margin: auto; display: block; width: 100%;"
src="diagrams/vc-graph.svg" alt="Diagram with a collections of
claims for a 'verifiable credential graph' on top
connected via a proof property (or predicate) to a 'verifiable credential proof
graph' on the bottom. The claims for a verifiable credential include 'Credential
123' as a subject with 4 properties: 'type' of value ExampleAlumniCredential,
'issuer' of Example University, 'validFrom' of 2010-01-01T19:23:24Z, and
credentialSubject of Pat, who also has an alumniOf property with value of
Example University.  The verifiable credential proof graph has an object
'Signature 456' subject with 5 properties: 'type' of DataIntegrityProof,
'verificationMethod' of Example University Public Key 7, 'created' of
2017-06-18T21:19:10Z, a 'nonce' of 34dj239dsj328, and 'proofValue' of
'zBavE110…3JT2pq'. The verifiable credential graph is also annotated with the
parenthetical remark '(the default graph)', the verifiable credential proof
graph is annotated with the parenthetical remark '(a named graph)'.">
<figcaption style="text-align: center;">
Information graphs associated with a basic verifiable credential
</figcaption>
</figure>

However, for general RDF Datasets, there is no such natural anchor nor an obvious way to identify the set of triples or quads that are supposed to be signed. The graph may be a forest or some much more complex directed graph; it may be part of a Dataset as a separate graph or indeed may not, etc. The identification of a graph or a dataset is not really part of the RDF Model.

<p class=note>
This issue was raised by the late Henry Story on a GitHub repository of the Verifiable Credentials Working Group: <a href="https://github.com/w3c/vc-data-model/issues/1248">issue #1248</a>. The issue was closed without solution: it was recognized as a general problem whose solution would go beyond what the Verifiable Credential Working Group was chartered to do, namely provide a securing solution for Credentials. Obviously, if a group is formed to generalize the [[vc-data-integrity]] approach for general RDF Datasets, this issue must be discussed.
</p>

It is for this reason that the answer to the general question, i.e., "Is it possible, using the [[[vc-data-integrity]]] specification, to secure, via cryptographic signatures, RDF Datasets in general?" is "Almost"

The approach taken by [[rdfjs-di]] is eminently pragmatic. The set of quads that must be signed is defined by the file that contains them, and it is up to the user to explicitly provide an anchor resource when running the code. The code lets the user choose to just generate a separate proof graph which is handled in an application dependent way, or to "embed" the proof graph using the `proof` property, yielding a structure like on [](#info-graph-vc). Here is the generated TriG file for the same example as above:


```turtle
@prefix sec: <https://w3id.org/security#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.
@prefix foaf: <http://xmlns.com/foaf/0.1/>.
@prefix earl: <http://www.w3.org/ns/earl#>.
    
<https://www.ivan-herman.net/foaf#me> a foaf:Person, earl:Assertor;
    foaf:name "Ivan Herman";
    foaf:title "Implementor";
    foaf:homepage <https://www.ivan-herman.net/>;
    sec:proof _:b0.
    
_:b0 {
    <urn:uuid:08bd1ede-34ea-4260-b698-81c2c28ccc0b> a sec:DataIntegrityProof;
        sec:verificationMethod <urn:uuid:33076c22-defc-45ec-8233-73e491cb4e69>;
        sec:created "2024-09-03T11:24:59.957Z"^^xsd:dateTime;
        sec:proofPurpose sec:authenticationMethod, sec:assertionMethod;
        sec:cryptosuite "eddsa-rdfc-2022";
        sec:proofValue "uhK6m9wekXiInuhnxv4Hx9rcs5--DbUZYZISpDeNuMEo2j48iZSB2Lp_OSd7D0h7Km0vRRbqWjWFknxis7JXBBA".
        
    <urn:uuid:33076c22-defc-45ec-8233-73e491cb4e69> a sec:Multikey;
        sec:controller <https://example.org/key/#ivan_eddsa>;
        sec:expires "2055-02-24T00:00:00Z"^^xsd:dateTime;
        sec:publicKeyMultibase "z6MkqPUPcdvvixcfgGqqEZJ4WZTiDwaCsqF8jHqR5UZA2iae".
}
```
